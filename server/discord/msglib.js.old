const debug = require("debug")("app:msglib");
const debugErr = require("debug")("app:error");
const { msg: msgConfig, messages, helpMessages, actionLists } = require("config");

const db = require("../db")
const { getStatus, getLists } = require("../api/trello");

const regexEscape = string => string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");

const hexToDecimal = hex => parseInt(hex.replace(/#/g, ""), 16);

const allCommands = [].concat(msgConfig.commands, msgConfig.boardCommands);

String.prototype.wrap = function (wrap) { return wrap + this + wrap };

const sendMessage = async (channel, data) => {
	let output = "";
	const board = await db.getBoard(data.board);

	switch (data.type) {
	case "cardMoved":
		output = `**[${data.name}](${data.shortUrl})** was moved to ${data.list}`;
		break;
	case "cardArchived":
		output = `**[${data.name}](${data.shortUrl})** was archived.`;
		break;
	case "cardAdded":
		break;
	default:
		return;
	}

	await sendFormatted(channel, output);

	if (Object.keys(board.lists).length !== actionLists.length && !!data.list) {
		await sendWarning(channel, "You need to configure your channel/board");
	}
}

const onMessage = async (msg) => {
	const { member, content, channel, author } = msg;

	if (content.indexOf(msgConfig.prefix + " ") === 0 && member.hasPermission("ADMINISTRATOR")) {
		debug(`Received command from @${author.username}`);

		try {
			const commandData = await processContent(content);
			const channelData = await processChannel(channel);

			if (msgConfig.boardCommands.includes(commandData.command) && !channelData.board) {
				throw new Error(messages.noBoard);
			}

			const result = await runCommand(commandData, channelData, channel);

			if (result) {
				msg.delete();
			}
		} catch (e) {
			console.error(e);
			await sendError(channel, e.message);
		}
	}
}

const commandRegex = new RegExp("(?:\")[^\"]*(?:\")|[^\\s]+", "g");

const processContent = async (content) => {
	const prefix = regexEscape(msgConfig.prefix);
	content = content.replace(new RegExp(`^${prefix}`), "");

	const matches = content.match(commandRegex);

	if (!matches.length) {
		throw new Error(messages.invalidFormat);
	}

	if (!allCommands.includes(matches[0])) {
		throw new Error(messages.invalidCommand);
	}

	return {
		command: matches[0],
		params: matches.splice(1, matches.length).map(param => param.replace(/\"/g, ""))
	}
}

const processChannel = async (channel) => {
	// connect to DB and get channel data
	const result = await db.getChannel(channel.id);

	const data = {
		channelId: channel.id
	};

	if (result) {
		return {
			...data,
			board: result.board
		}
	}

	return data;
}

const runCommand = async (commandData, channelData, channel) => {
	debug(`Running the "${commandData.command}" command`);
	switch (commandData.command) {
	case "addBoard":
		const param = commandData.params[0];
		const result = await db.addChannel(param, channelData.channelId);

		if (result) {
			sendFormatted(channel, messages.channelAdded);
		}
		break;
	case "status":
		const board = await db.getBoard(null, channelData.board);

		if (board) {
			const status = await getStatus(board.boardId);
			console.log(status);

			if (status === false) {
				await sendWarning(channel, "You need to configure your channel/board");
				return false;
			}

			const content = Object.keys(status).reduce((out, list) => ([
				...out,
				{
					name: list.replace(/^./, match => match.toUpperCase()),
					value: status[list].length
						? status[list].reduce((str, card) => {
							return `${str}\n - [${card.name}](${card.shortUrl})`;
						}, "")
						: "None"
				}
			]), []);

			sendFormatted(channel, { fields: content })
		}
		break;
	case "help":
		if (commandData.params.length) {
			const param = commandData.params[0];
			if (!helpMessages.hasOwnProperty(param)) {
				throw new Error(messages.helpInvalid);
			} else {
				await sendFormatted(channel, helpMessages[param]);
			}
		} else {
			await sendFormatted(channel, "generic help");
		}
		break;
	case "configure":
		const boardLists = await getLists(channelData.board);
		const { params } = commandData;

		if (params.length === 0) {
			const actionsString = actionLists.map(a => a.wrap("**")).join(" | ");

			const listsString = boardLists.reduce((out, list) => {
				return `${out}\n- ${list.name} | **${list.id}**`;
			}, "");

			let example = msgConfig.prefix + " configure ";
			example += Object.keys(boardLists)
				.slice(0, actionLists.length)
				.reduce((arr, k) => ([...arr, k % 2 !== 0 ? boardLists[k].id : boardLists[k].name.wrap("\"")]), [])
				.join(" ");
			example = example.wrap("`");

			sendFormatted(channel, {
				description: `Please use the list's *name* or *ID* provided in the list below.\n**Example:** ${example}`,
				fields: [
					{ name: "Actions", value: actionsString },
					{ name: "Lists", value: listsString }
				]
			});
			return true;
		}

		const invalidLists = params.filter(list => !boardLists.find(l => (l.id === list || l.name === list)));

		if (invalidLists.length) {
			throw new Error("You have provided lists that do not exist on the Trello board: " + invalidLists.join(", "));
		}

		if (params.length !== actionLists.length) {
			const example = `${msgConfig.prefix} configure`.wrap("`");
			await sendWarning(channel, `Your provided parameters do not include all the actions listed.\nType ${example} to see all the required actions and available lists.`);
		}

		const selectedLists = Object.keys(actionLists).reduce((out, key) => ({
			...out,
			[actionLists[key]]: boardLists.find(l => (l.id === params[key] || l.name === params[key])).id
		}), {});

		await db.saveLists(channelData.board, selectedLists);

		await sendFormatted(channel, "Channel has been configured");
		break;
	default:
		debug(`${commandData.command} isn't configured with this bot, but is registered as valid.`);
		throw new Error(messages.unknownError);
		break;
	}

	return true;
}

const sendError = (channel, content) => {
	content = processMessage(content);

	return sendFormatted(channel, {
		title: "Error",
		color: hexToDecimal(msgConfig.colours.error),
		...content
	});
}

const sendWarning = (channel, content) => {
	content = processMessage(content);

	return sendFormatted(channel, {
		title: "Warning",
		color: hexToDecimal(msgConfig.colours.warning),
		...content
	});
}

const sendFormatted = (channel, content, type) => {
	content = processMessage(content);

	return channel.send("", {
		embed: {
			title: "TrelloMan",
			color: hexToDecimal(msgConfig.colours.main),
			...content
		}
	});
}

const processMessage = content => (typeof content === "string" ? { description: content } : content);

module.exports = {
	onMessage,
	sendMessage
}
